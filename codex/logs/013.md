# Ticket 013 — Rust Parser Adapter (pyo3) — Header + Network Stub

**Ticket:** codex/tickets/013-rust-parser-adapter.md

**Summary**
- Added a Rust crate (`parsers/rlreplay_rust`) exposing `parse_header` and `iter_frames` via `pyo3`.
- Implemented Python shim `src/rlcoach/parser/rust_adapter.py` that integrates with the existing adapter interface and degrades gracefully if the Rust core is not installed.
- Registered adapter as `get_adapter('rust')`.
- Added docs for build/usage and tests validating header parse and adapter selection.

**Details**
- Rust `parse_header(path)` reads the file, checks for replay markers in the first ~2KB, and returns a minimal, deterministic header dict with placeholder values and quality warnings (`rust_core_stub_header`).
- Rust `iter_frames(path)` returns an empty iterator (stub), suitable as a foundation for future work.
- Python shim converts the Rust dict to the `Header` dataclass and, when the Rust core is unavailable, falls back to ingest + placeholder header with warnings (`rust_core_unavailable_fallback_header_only`, `network_data_unparsed_fallback_header_only`).
- Tests:
  - `tests/test_rust_adapter.py` creates a small synthetic replay-like file and asserts the `rust` adapter returns a valid `Header`; it also validates network behavior (stub vs None).

**How to Build Locally**
1) `cd parsers/rlreplay_rust`
2) `pip install maturin`
3) `maturin develop` (installs `rlreplay_rust` into the current environment)
4) `pytest -q`

**Acceptance**
- `pytest -q` passes; `get_adapter('rust')` is available and parses header fields. Build steps documented.

**Next Steps**
- Integrate `boxcars`/`rrrocket` to populate real header/frames and enable actual network parsing.

